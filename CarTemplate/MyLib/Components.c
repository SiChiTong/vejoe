#include "Components.h"
#include "Device.h"

//-----------------------OLED------------------------------------------------------
#ifdef COMPONENTS_OLED
  
	#include "stm32f10x_pwr.h"
	#include "stm32f10x_bkp.h"
	
	u8 oledRst,oledDc,oledScl,oledSda;
	u8 OLED_GRAM[128][8];	
	const unsigned char oled_asc2_1206[95][12]={
		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*" ",0*/
		{0x00,0x00,0x00,0x00,0x3F,0x40,0x00,0x00,0x00,0x00,0x00,0x00},/*"!",1*/
		{0x00,0x00,0x30,0x00,0x40,0x00,0x30,0x00,0x40,0x00,0x00,0x00},/*""",2*/
		{0x09,0x00,0x0B,0xC0,0x3D,0x00,0x0B,0xC0,0x3D,0x00,0x09,0x00},/*"#",3*/
		{0x18,0xC0,0x24,0x40,0x7F,0xE0,0x22,0x40,0x31,0x80,0x00,0x00},/*"$",4*/
		{0x18,0x00,0x24,0xC0,0x1B,0x00,0x0D,0x80,0x32,0x40,0x01,0x80},/*"%",5*/
		{0x03,0x80,0x1C,0x40,0x27,0x40,0x1C,0x80,0x07,0x40,0x00,0x40},/*"&",6*/
		{0x10,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"'",7*/
		{0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x80,0x20,0x40,0x40,0x20},/*"(",8*/
		{0x00,0x00,0x40,0x20,0x20,0x40,0x1F,0x80,0x00,0x00,0x00,0x00},/*")",9*/
		{0x09,0x00,0x06,0x00,0x1F,0x80,0x06,0x00,0x09,0x00,0x00,0x00},/*"*",10*/
		{0x04,0x00,0x04,0x00,0x3F,0x80,0x04,0x00,0x04,0x00,0x00,0x00},/*"+",11*/
		{0x00,0x10,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*",",12*/
		{0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x00,0x00},/*"-",13*/
		{0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*".",14*/
		{0x00,0x20,0x01,0xC0,0x06,0x00,0x38,0x00,0x40,0x00,0x00,0x00},/*"/",15*/
		{0x1F,0x80,0x20,0x40,0x20,0x40,0x20,0x40,0x1F,0x80,0x00,0x00},/*"0",16*/
		{0x00,0x00,0x10,0x40,0x3F,0xC0,0x00,0x40,0x00,0x00,0x00,0x00},/*"1",17*/
		{0x18,0xC0,0x21,0x40,0x22,0x40,0x24,0x40,0x18,0x40,0x00,0x00},/*"2",18*/
		{0x10,0x80,0x20,0x40,0x24,0x40,0x24,0x40,0x1B,0x80,0x00,0x00},/*"3",19*/
		{0x02,0x00,0x0D,0x00,0x11,0x00,0x3F,0xC0,0x01,0x40,0x00,0x00},/*"4",20*/
		{0x3C,0x80,0x24,0x40,0x24,0x40,0x24,0x40,0x23,0x80,0x00,0x00},/*"5",21*/
		{0x1F,0x80,0x24,0x40,0x24,0x40,0x34,0x40,0x03,0x80,0x00,0x00},/*"6",22*/
		{0x30,0x00,0x20,0x00,0x27,0xC0,0x38,0x00,0x20,0x00,0x00,0x00},/*"7",23*/
		{0x1B,0x80,0x24,0x40,0x24,0x40,0x24,0x40,0x1B,0x80,0x00,0x00},/*"8",24*/
		{0x1C,0x00,0x22,0xC0,0x22,0x40,0x22,0x40,0x1F,0x80,0x00,0x00},/*"9",25*/
		{0x00,0x00,0x00,0x00,0x08,0x40,0x00,0x00,0x00,0x00,0x00,0x00},/*":",26*/
		{0x00,0x00,0x00,0x00,0x04,0x60,0x00,0x00,0x00,0x00,0x00,0x00},/*";",27*/
		{0x00,0x00,0x04,0x00,0x0A,0x00,0x11,0x00,0x20,0x80,0x40,0x40},/*"<",28*/
		{0x09,0x00,0x09,0x00,0x09,0x00,0x09,0x00,0x09,0x00,0x00,0x00},/*"=",29*/
		{0x00,0x00,0x40,0x40,0x20,0x80,0x11,0x00,0x0A,0x00,0x04,0x00},/*">",30*/
		{0x18,0x00,0x20,0x00,0x23,0x40,0x24,0x00,0x18,0x00,0x00,0x00},/*"?",31*/
		{0x1F,0x80,0x20,0x40,0x27,0x40,0x29,0x40,0x1F,0x40,0x00,0x00},/*"@",32*/
		{0x00,0x40,0x07,0xC0,0x39,0x00,0x0F,0x00,0x01,0xC0,0x00,0x40},/*"A",33*/
		{0x20,0x40,0x3F,0xC0,0x24,0x40,0x24,0x40,0x1B,0x80,0x00,0x00},/*"B",34*/
		{0x1F,0x80,0x20,0x40,0x20,0x40,0x20,0x40,0x30,0x80,0x00,0x00},/*"C",35*/
		{0x20,0x40,0x3F,0xC0,0x20,0x40,0x20,0x40,0x1F,0x80,0x00,0x00},/*"D",36*/
		{0x20,0x40,0x3F,0xC0,0x24,0x40,0x2E,0x40,0x30,0xC0,0x00,0x00},/*"E",37*/
		{0x20,0x40,0x3F,0xC0,0x24,0x40,0x2E,0x00,0x30,0x00,0x00,0x00},/*"F",38*/
		{0x0F,0x00,0x10,0x80,0x20,0x40,0x22,0x40,0x33,0x80,0x02,0x00},/*"G",39*/
		{0x20,0x40,0x3F,0xC0,0x04,0x00,0x04,0x00,0x3F,0xC0,0x20,0x40},/*"H",40*/
		{0x20,0x40,0x20,0x40,0x3F,0xC0,0x20,0x40,0x20,0x40,0x00,0x00},/*"I",41*/
		{0x00,0x60,0x20,0x20,0x20,0x20,0x3F,0xC0,0x20,0x00,0x20,0x00},/*"J",42*/
		{0x20,0x40,0x3F,0xC0,0x24,0x40,0x0B,0x00,0x30,0xC0,0x20,0x40},/*"K",43*/
		{0x20,0x40,0x3F,0xC0,0x20,0x40,0x00,0x40,0x00,0x40,0x00,0xC0},/*"L",44*/
		{0x3F,0xC0,0x3C,0x00,0x03,0xC0,0x3C,0x00,0x3F,0xC0,0x00,0x00},/*"M",45*/
		{0x20,0x40,0x3F,0xC0,0x0C,0x40,0x23,0x00,0x3F,0xC0,0x20,0x00},/*"N",46*/
		{0x1F,0x80,0x20,0x40,0x20,0x40,0x20,0x40,0x1F,0x80,0x00,0x00},/*"O",47*/
		{0x20,0x40,0x3F,0xC0,0x24,0x40,0x24,0x00,0x18,0x00,0x00,0x00},/*"P",48*/
		{0x1F,0x80,0x21,0x40,0x21,0x40,0x20,0xE0,0x1F,0xA0,0x00,0x00},/*"Q",49*/
		{0x20,0x40,0x3F,0xC0,0x24,0x40,0x26,0x00,0x19,0xC0,0x00,0x40},/*"R",50*/
		{0x18,0xC0,0x24,0x40,0x24,0x40,0x22,0x40,0x31,0x80,0x00,0x00},/*"S",51*/
		{0x30,0x00,0x20,0x40,0x3F,0xC0,0x20,0x40,0x30,0x00,0x00,0x00},/*"T",52*/
		{0x20,0x00,0x3F,0x80,0x00,0x40,0x00,0x40,0x3F,0x80,0x20,0x00},/*"U",53*/
		{0x20,0x00,0x3E,0x00,0x01,0xC0,0x07,0x00,0x38,0x00,0x20,0x00},/*"V",54*/
		{0x38,0x00,0x07,0xC0,0x3C,0x00,0x07,0xC0,0x38,0x00,0x00,0x00},/*"W",55*/
		{0x20,0x40,0x39,0xC0,0x06,0x00,0x39,0xC0,0x20,0x40,0x00,0x00},/*"X",56*/
		{0x20,0x00,0x38,0x40,0x07,0xC0,0x38,0x40,0x20,0x00,0x00,0x00},/*"Y",57*/
		{0x30,0x40,0x21,0xC0,0x26,0x40,0x38,0x40,0x20,0xC0,0x00,0x00},/*"Z",58*/
		{0x00,0x00,0x00,0x00,0x7F,0xE0,0x40,0x20,0x40,0x20,0x00,0x00},/*"[",59*/
		{0x00,0x00,0x70,0x00,0x0C,0x00,0x03,0x80,0x00,0x40,0x00,0x00},/*"\",60*/
		{0x00,0x00,0x40,0x20,0x40,0x20,0x7F,0xE0,0x00,0x00,0x00,0x00},/*"]",61*/
		{0x00,0x00,0x20,0x00,0x40,0x00,0x20,0x00,0x00,0x00,0x00,0x00},/*"^",62*/
		{0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10,0x00,0x10},/*"_",63*/
		{0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"`",64*/
		{0x00,0x00,0x02,0x80,0x05,0x40,0x05,0x40,0x03,0xC0,0x00,0x40},/*"a",65*/
		{0x20,0x00,0x3F,0xC0,0x04,0x40,0x04,0x40,0x03,0x80,0x00,0x00},/*"b",66*/
		{0x00,0x00,0x03,0x80,0x04,0x40,0x04,0x40,0x06,0x40,0x00,0x00},/*"c",67*/
		{0x00,0x00,0x03,0x80,0x04,0x40,0x24,0x40,0x3F,0xC0,0x00,0x40},/*"d",68*/
		{0x00,0x00,0x03,0x80,0x05,0x40,0x05,0x40,0x03,0x40,0x00,0x00},/*"e",69*/
		{0x00,0x00,0x04,0x40,0x1F,0xC0,0x24,0x40,0x24,0x40,0x20,0x00},/*"f",70*/
		{0x00,0x00,0x02,0xE0,0x05,0x50,0x05,0x50,0x06,0x50,0x04,0x20},/*"g",71*/
		{0x20,0x40,0x3F,0xC0,0x04,0x40,0x04,0x00,0x03,0xC0,0x00,0x40},/*"h",72*/
		{0x00,0x00,0x04,0x40,0x27,0xC0,0x00,0x40,0x00,0x00,0x00,0x00},/*"i",73*/
		{0x00,0x10,0x00,0x10,0x04,0x10,0x27,0xE0,0x00,0x00,0x00,0x00},/*"j",74*/
		{0x20,0x40,0x3F,0xC0,0x01,0x40,0x07,0x00,0x04,0xC0,0x04,0x40},/*"k",75*/
		{0x20,0x40,0x20,0x40,0x3F,0xC0,0x00,0x40,0x00,0x40,0x00,0x00},/*"l",76*/
		{0x07,0xC0,0x04,0x00,0x07,0xC0,0x04,0x00,0x03,0xC0,0x00,0x00},/*"m",77*/
		{0x04,0x40,0x07,0xC0,0x04,0x40,0x04,0x00,0x03,0xC0,0x00,0x40},/*"n",78*/
		{0x00,0x00,0x03,0x80,0x04,0x40,0x04,0x40,0x03,0x80,0x00,0x00},/*"o",79*/
		{0x04,0x10,0x07,0xF0,0x04,0x50,0x04,0x40,0x03,0x80,0x00,0x00},/*"p",80*/
		{0x00,0x00,0x03,0x80,0x04,0x40,0x04,0x50,0x07,0xF0,0x00,0x10},/*"q",81*/
		{0x04,0x40,0x07,0xC0,0x02,0x40,0x04,0x00,0x04,0x00,0x00,0x00},/*"r",82*/
		{0x00,0x00,0x06,0x40,0x05,0x40,0x05,0x40,0x04,0xC0,0x00,0x00},/*"s",83*/
		{0x00,0x00,0x04,0x00,0x1F,0x80,0x04,0x40,0x00,0x40,0x00,0x00},/*"t",84*/
		{0x04,0x00,0x07,0x80,0x00,0x40,0x04,0x40,0x07,0xC0,0x00,0x40},/*"u",85*/
		{0x04,0x00,0x07,0x00,0x04,0xC0,0x01,0x80,0x06,0x00,0x04,0x00},/*"v",86*/
		{0x06,0x00,0x01,0xC0,0x07,0x00,0x01,0xC0,0x06,0x00,0x00,0x00},/*"w",87*/
		{0x04,0x40,0x06,0xC0,0x01,0x00,0x06,0xC0,0x04,0x40,0x00,0x00},/*"x",88*/
		{0x04,0x10,0x07,0x10,0x04,0xE0,0x01,0x80,0x06,0x00,0x04,0x00},/*"y",89*/
		{0x00,0x00,0x04,0x40,0x05,0xC0,0x06,0x40,0x04,0x40,0x00,0x00},/*"z",90*/
		{0x00,0x00,0x00,0x00,0x04,0x00,0x7B,0xE0,0x40,0x20,0x00,0x00},/*"{",91*/
		{0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xF0,0x00,0x00,0x00,0x00},/*"|",92*/
		{0x00,0x00,0x40,0x20,0x7B,0xE0,0x04,0x00,0x00,0x00,0x00,0x00},/*"}",93*/
		{0x40,0x00,0x80,0x00,0x40,0x00,0x20,0x00,0x20,0x00,0x40,0x00},/*"~",94*/
	}; 
	const unsigned char oled_asc2_1608[95][16]={	  
		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*" ",0*/
		{0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xCC,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x00},/*"!",1*/
		{0x00,0x00,0x08,0x00,0x30,0x00,0x60,0x00,0x08,0x00,0x30,0x00,0x60,0x00,0x00,0x00},/*""",2*/
		{0x02,0x20,0x03,0xFC,0x1E,0x20,0x02,0x20,0x03,0xFC,0x1E,0x20,0x02,0x20,0x00,0x00},/*"#",3*/
		{0x00,0x00,0x0E,0x18,0x11,0x04,0x3F,0xFF,0x10,0x84,0x0C,0x78,0x00,0x00,0x00,0x00},/*"$",4*/
		{0x0F,0x00,0x10,0x84,0x0F,0x38,0x00,0xC0,0x07,0x78,0x18,0x84,0x00,0x78,0x00,0x00},/*"%",5*/
		{0x00,0x78,0x0F,0x84,0x10,0xC4,0x11,0x24,0x0E,0x98,0x00,0xE4,0x00,0x84,0x00,0x08},/*"&",6*/
		{0x08,0x00,0x68,0x00,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"'",7*/
		{0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xE0,0x18,0x18,0x20,0x04,0x40,0x02,0x00,0x00},/*"(",8*/
		{0x00,0x00,0x40,0x02,0x20,0x04,0x18,0x18,0x07,0xE0,0x00,0x00,0x00,0x00,0x00,0x00},/*")",9*/
		{0x02,0x40,0x02,0x40,0x01,0x80,0x0F,0xF0,0x01,0x80,0x02,0x40,0x02,0x40,0x00,0x00},/*"*",10*/
		{0x00,0x80,0x00,0x80,0x00,0x80,0x0F,0xF8,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x00},/*"+",11*/
		{0x00,0x01,0x00,0x0D,0x00,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*",",12*/
		{0x00,0x00,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80},/*"-",13*/
		{0x00,0x00,0x00,0x0C,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*".",14*/
		{0x00,0x00,0x00,0x06,0x00,0x18,0x00,0x60,0x01,0x80,0x06,0x00,0x18,0x00,0x20,0x00},/*"/",15*/
		{0x00,0x00,0x07,0xF0,0x08,0x08,0x10,0x04,0x10,0x04,0x08,0x08,0x07,0xF0,0x00,0x00},/*"0",16*/
		{0x00,0x00,0x08,0x04,0x08,0x04,0x1F,0xFC,0x00,0x04,0x00,0x04,0x00,0x00,0x00,0x00},/*"1",17*/
		{0x00,0x00,0x0E,0x0C,0x10,0x14,0x10,0x24,0x10,0x44,0x11,0x84,0x0E,0x0C,0x00,0x00},/*"2",18*/
		{0x00,0x00,0x0C,0x18,0x10,0x04,0x11,0x04,0x11,0x04,0x12,0x88,0x0C,0x70,0x00,0x00},/*"3",19*/
		{0x00,0x00,0x00,0xE0,0x03,0x20,0x04,0x24,0x08,0x24,0x1F,0xFC,0x00,0x24,0x00,0x00},/*"4",20*/
		{0x00,0x00,0x1F,0x98,0x10,0x84,0x11,0x04,0x11,0x04,0x10,0x88,0x10,0x70,0x00,0x00},/*"5",21*/
		{0x00,0x00,0x07,0xF0,0x08,0x88,0x11,0x04,0x11,0x04,0x18,0x88,0x00,0x70,0x00,0x00},/*"6",22*/
		{0x00,0x00,0x1C,0x00,0x10,0x00,0x10,0xFC,0x13,0x00,0x1C,0x00,0x10,0x00,0x00,0x00},/*"7",23*/
		{0x00,0x00,0x0E,0x38,0x11,0x44,0x10,0x84,0x10,0x84,0x11,0x44,0x0E,0x38,0x00,0x00},/*"8",24*/
		{0x00,0x00,0x07,0x00,0x08,0x8C,0x10,0x44,0x10,0x44,0x08,0x88,0x07,0xF0,0x00,0x00},/*"9",25*/
		{0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x0C,0x03,0x0C,0x00,0x00,0x00,0x00,0x00,0x00},/*":",26*/
		{0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*";",27*/
		{0x00,0x00,0x00,0x80,0x01,0x40,0x02,0x20,0x04,0x10,0x08,0x08,0x10,0x04,0x00,0x00},/*"<",28*/
		{0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x02,0x20,0x00,0x00},/*"=",29*/
		{0x00,0x00,0x10,0x04,0x08,0x08,0x04,0x10,0x02,0x20,0x01,0x40,0x00,0x80,0x00,0x00},/*">",30*/
		{0x00,0x00,0x0E,0x00,0x12,0x00,0x10,0x0C,0x10,0x6C,0x10,0x80,0x0F,0x00,0x00,0x00},/*"?",31*/
		{0x03,0xE0,0x0C,0x18,0x13,0xE4,0x14,0x24,0x17,0xC4,0x08,0x28,0x07,0xD0,0x00,0x00},/*"@",32*/
		{0x00,0x04,0x00,0x3C,0x03,0xC4,0x1C,0x40,0x07,0x40,0x00,0xE4,0x00,0x1C,0x00,0x04},/*"A",33*/
		{0x10,0x04,0x1F,0xFC,0x11,0x04,0x11,0x04,0x11,0x04,0x0E,0x88,0x00,0x70,0x00,0x00},/*"B",34*/
		{0x03,0xE0,0x0C,0x18,0x10,0x04,0x10,0x04,0x10,0x04,0x10,0x08,0x1C,0x10,0x00,0x00},/*"C",35*/
		{0x10,0x04,0x1F,0xFC,0x10,0x04,0x10,0x04,0x10,0x04,0x08,0x08,0x07,0xF0,0x00,0x00},/*"D",36*/
		{0x10,0x04,0x1F,0xFC,0x11,0x04,0x11,0x04,0x17,0xC4,0x10,0x04,0x08,0x18,0x00,0x00},/*"E",37*/
		{0x10,0x04,0x1F,0xFC,0x11,0x04,0x11,0x00,0x17,0xC0,0x10,0x00,0x08,0x00,0x00,0x00},/*"F",38*/
		{0x03,0xE0,0x0C,0x18,0x10,0x04,0x10,0x04,0x10,0x44,0x1C,0x78,0x00,0x40,0x00,0x00},/*"G",39*/
		{0x10,0x04,0x1F,0xFC,0x10,0x84,0x00,0x80,0x00,0x80,0x10,0x84,0x1F,0xFC,0x10,0x04},/*"H",40*/
		{0x00,0x00,0x10,0x04,0x10,0x04,0x1F,0xFC,0x10,0x04,0x10,0x04,0x00,0x00,0x00,0x00},/*"I",41*/
		{0x00,0x03,0x00,0x01,0x10,0x01,0x10,0x01,0x1F,0xFE,0x10,0x00,0x10,0x00,0x00,0x00},/*"J",42*/
		{0x10,0x04,0x1F,0xFC,0x11,0x04,0x03,0x80,0x14,0x64,0x18,0x1C,0x10,0x04,0x00,0x00},/*"K",43*/
		{0x10,0x04,0x1F,0xFC,0x10,0x04,0x00,0x04,0x00,0x04,0x00,0x04,0x00,0x0C,0x00,0x00},/*"L",44*/
		{0x10,0x04,0x1F,0xFC,0x1F,0x00,0x00,0xFC,0x1F,0x00,0x1F,0xFC,0x10,0x04,0x00,0x00},/*"M",45*/
		{0x10,0x04,0x1F,0xFC,0x0C,0x04,0x03,0x00,0x00,0xE0,0x10,0x18,0x1F,0xFC,0x10,0x00},/*"N",46*/
		{0x07,0xF0,0x08,0x08,0x10,0x04,0x10,0x04,0x10,0x04,0x08,0x08,0x07,0xF0,0x00,0x00},/*"O",47*/
		{0x10,0x04,0x1F,0xFC,0x10,0x84,0x10,0x80,0x10,0x80,0x10,0x80,0x0F,0x00,0x00,0x00},/*"P",48*/
		{0x07,0xF0,0x08,0x18,0x10,0x24,0x10,0x24,0x10,0x1C,0x08,0x0A,0x07,0xF2,0x00,0x00},/*"Q",49*/
		{0x10,0x04,0x1F,0xFC,0x11,0x04,0x11,0x00,0x11,0xC0,0x11,0x30,0x0E,0x0C,0x00,0x04},/*"R",50*/
		{0x00,0x00,0x0E,0x1C,0x11,0x04,0x10,0x84,0x10,0x84,0x10,0x44,0x1C,0x38,0x00,0x00},/*"S",51*/
		{0x18,0x00,0x10,0x00,0x10,0x04,0x1F,0xFC,0x10,0x04,0x10,0x00,0x18,0x00,0x00,0x00},/*"T",52*/
		{0x10,0x00,0x1F,0xF8,0x10,0x04,0x00,0x04,0x00,0x04,0x10,0x04,0x1F,0xF8,0x10,0x00},/*"U",53*/
		{0x10,0x00,0x1E,0x00,0x11,0xE0,0x00,0x1C,0x00,0x70,0x13,0x80,0x1C,0x00,0x10,0x00},/*"V",54*/
		{0x1F,0xC0,0x10,0x3C,0x00,0xE0,0x1F,0x00,0x00,0xE0,0x10,0x3C,0x1F,0xC0,0x00,0x00},/*"W",55*/
		{0x10,0x04,0x18,0x0C,0x16,0x34,0x01,0xC0,0x01,0xC0,0x16,0x34,0x18,0x0C,0x10,0x04},/*"X",56*/
		{0x10,0x00,0x1C,0x00,0x13,0x04,0x00,0xFC,0x13,0x04,0x1C,0x00,0x10,0x00,0x00,0x00},/*"Y",57*/
		{0x08,0x04,0x10,0x1C,0x10,0x64,0x10,0x84,0x13,0x04,0x1C,0x04,0x10,0x18,0x00,0x00},/*"Z",58*/
		{0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFE,0x40,0x02,0x40,0x02,0x40,0x02,0x00,0x00},/*"[",59*/
		{0x00,0x00,0x30,0x00,0x0C,0x00,0x03,0x80,0x00,0x60,0x00,0x1C,0x00,0x03,0x00,0x00},/*"\",60*/
		{0x00,0x00,0x40,0x02,0x40,0x02,0x40,0x02,0x7F,0xFE,0x00,0x00,0x00,0x00,0x00,0x00},/*"]",61*/
		{0x00,0x00,0x00,0x00,0x20,0x00,0x40,0x00,0x40,0x00,0x40,0x00,0x20,0x00,0x00,0x00},/*"^",62*/
		{0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01},/*"_",63*/
		{0x00,0x00,0x40,0x00,0x40,0x00,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"`",64*/
		{0x00,0x00,0x00,0x98,0x01,0x24,0x01,0x44,0x01,0x44,0x01,0x44,0x00,0xFC,0x00,0x04},/*"a",65*/
		{0x10,0x00,0x1F,0xFC,0x00,0x88,0x01,0x04,0x01,0x04,0x00,0x88,0x00,0x70,0x00,0x00},/*"b",66*/
		{0x00,0x00,0x00,0x70,0x00,0x88,0x01,0x04,0x01,0x04,0x01,0x04,0x00,0x88,0x00,0x00},/*"c",67*/
		{0x00,0x00,0x00,0x70,0x00,0x88,0x01,0x04,0x01,0x04,0x11,0x08,0x1F,0xFC,0x00,0x04},/*"d",68*/
		{0x00,0x00,0x00,0xF8,0x01,0x44,0x01,0x44,0x01,0x44,0x01,0x44,0x00,0xC8,0x00,0x00},/*"e",69*/
		{0x00,0x00,0x01,0x04,0x01,0x04,0x0F,0xFC,0x11,0x04,0x11,0x04,0x11,0x00,0x18,0x00},/*"f",70*/
		{0x00,0x00,0x00,0xD6,0x01,0x29,0x01,0x29,0x01,0x29,0x01,0xC9,0x01,0x06,0x00,0x00},/*"g",71*/
		{0x10,0x04,0x1F,0xFC,0x00,0x84,0x01,0x00,0x01,0x00,0x01,0x04,0x00,0xFC,0x00,0x04},/*"h",72*/
		{0x00,0x00,0x01,0x04,0x19,0x04,0x19,0xFC,0x00,0x04,0x00,0x04,0x00,0x00,0x00,0x00},/*"i",73*/
		{0x00,0x00,0x00,0x03,0x00,0x01,0x01,0x01,0x19,0x01,0x19,0xFE,0x00,0x00,0x00,0x00},/*"j",74*/
		{0x10,0x04,0x1F,0xFC,0x00,0x24,0x00,0x40,0x01,0xB4,0x01,0x0C,0x01,0x04,0x00,0x00},/*"k",75*/
		{0x00,0x00,0x10,0x04,0x10,0x04,0x1F,0xFC,0x00,0x04,0x00,0x04,0x00,0x00,0x00,0x00},/*"l",76*/
		{0x01,0x04,0x01,0xFC,0x01,0x04,0x01,0x00,0x01,0xFC,0x01,0x04,0x01,0x00,0x00,0xFC},/*"m",77*/
		{0x01,0x04,0x01,0xFC,0x00,0x84,0x01,0x00,0x01,0x00,0x01,0x04,0x00,0xFC,0x00,0x04},/*"n",78*/
		{0x00,0x00,0x00,0xF8,0x01,0x04,0x01,0x04,0x01,0x04,0x01,0x04,0x00,0xF8,0x00,0x00},/*"o",79*/
		{0x01,0x01,0x01,0xFF,0x00,0x85,0x01,0x04,0x01,0x04,0x00,0x88,0x00,0x70,0x00,0x00},/*"p",80*/
		{0x00,0x00,0x00,0x70,0x00,0x88,0x01,0x04,0x01,0x04,0x01,0x05,0x01,0xFF,0x00,0x01},/*"q",81*/
		{0x01,0x04,0x01,0x04,0x01,0xFC,0x00,0x84,0x01,0x04,0x01,0x00,0x01,0x80,0x00,0x00},/*"r",82*/
		{0x00,0x00,0x00,0xCC,0x01,0x24,0x01,0x24,0x01,0x24,0x01,0x24,0x01,0x98,0x00,0x00},/*"s",83*/
		{0x00,0x00,0x01,0x00,0x01,0x00,0x07,0xF8,0x01,0x04,0x01,0x04,0x00,0x00,0x00,0x00},/*"t",84*/
		{0x01,0x00,0x01,0xF8,0x00,0x04,0x00,0x04,0x00,0x04,0x01,0x08,0x01,0xFC,0x00,0x04},/*"u",85*/
		{0x01,0x00,0x01,0x80,0x01,0x70,0x00,0x0C,0x00,0x10,0x01,0x60,0x01,0x80,0x01,0x00},/*"v",86*/
		{0x01,0xF0,0x01,0x0C,0x00,0x30,0x01,0xC0,0x00,0x30,0x01,0x0C,0x01,0xF0,0x01,0x00},/*"w",87*/
		{0x00,0x00,0x01,0x04,0x01,0x8C,0x00,0x74,0x01,0x70,0x01,0x8C,0x01,0x04,0x00,0x00},/*"x",88*/
		{0x01,0x01,0x01,0x81,0x01,0x71,0x00,0x0E,0x00,0x18,0x01,0x60,0x01,0x80,0x01,0x00},/*"y",89*/
		{0x00,0x00,0x01,0x84,0x01,0x0C,0x01,0x34,0x01,0x44,0x01,0x84,0x01,0x0C,0x00,0x00},/*"z",90*/
		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x3E,0xFC,0x40,0x02,0x40,0x02},/*"{",91*/
		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00},/*"|",92*/
		{0x00,0x00,0x40,0x02,0x40,0x02,0x3E,0xFC,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"}",93*/
		{0x00,0x00,0x60,0x00,0x80,0x00,0x80,0x00,0x40,0x00,0x40,0x00,0x20,0x00,0x20,0x00},/*"~",94*/
	};      
	
	
	void OLED_WR_Byte(u8 dat,u8 cmd);	 
		
	void OLED_RST_Clr(void)   //RST
	{
		PCout(oledRst)=0;
	}
	void OLED_RST_Set(void)   //RST
	{
		PCout(oledRst)=1;
	}
	void OLED_RS_Clr(void)    //DC
	{
		PCout(oledDc)=0;
	}
	void OLED_RS_Set(void)    //DC
	{
		PCout(oledDc)=1;
	}
	void OLED_SCLK_Clr(void)  //SCL
	{
		PCout(oledScl)=0;
	}
	void OLED_SCLK_Set(void)  //SCL
	{
		PCout(oledScl)=1;
	}
	void OLED_SDIN_Clr(void)  //SDA
	{
		PCout(oledSda)=0;
	}
	void OLED_SDIN_Set(void)  //SDA
	{
		PCout(oledSda)=1;
	}
	void OLED_Refresh_Gram(void)
	{
		u8 i,n;		    
		for(i=0;i<8;i++)  
		{  
			OLED_WR_Byte (0xb0+i,OLED_CMD);    //设置页地址（0~7）
			OLED_WR_Byte (0x00,OLED_CMD);      //设置显示位置―列低地址
			OLED_WR_Byte (0x10,OLED_CMD);      //设置显示位置―列高地址   
			for(n=0;n<128;n++)OLED_WR_Byte(OLED_GRAM[n][i],OLED_DATA); 
		}
	}

	//向OLED写入一个字节。
	//dat:要写入的数据/命令
	//cmd:数据/命令标志 0,表示命令;1,表示数据;
	void OLED_WR_Byte(u8 dat,u8 cmd)
	{	
		u8 i;			  
		if(cmd)
			OLED_RS_Set();
		else 
			OLED_RS_Clr();		  
		for(i=0;i<8;i++)
		{			  
			OLED_SCLK_Clr();
			if(dat&0x80)
			OLED_SDIN_Set();
			else 
			OLED_SDIN_Clr();
			OLED_SCLK_Set();
			dat<<=1;   
		}				 		  
		OLED_RS_Set();   	  
	} 

					
	//开启OLED显示    
	void OLED_Display_On(void)
	{
		OLED_WR_Byte(0X8D,OLED_CMD);  //SET DCDC命令
		OLED_WR_Byte(0X14,OLED_CMD);  //DCDC ON
		OLED_WR_Byte(0XAF,OLED_CMD);  //DISPLAY ON
	}
	//关闭OLED显示     
	void OLED_Display_Off(void)
	{
		OLED_WR_Byte(0X8D,OLED_CMD);  //SET DCDC命令
		OLED_WR_Byte(0X10,OLED_CMD);  //DCDC OFF
		OLED_WR_Byte(0XAE,OLED_CMD);  //DISPLAY OFF
	}		   			 
	//清屏函数,清完屏,整个屏幕是黑色的!和没点亮一样!!!	  
	void OLED_Clear(void)  
	{  
		u8 i,n;  
		for(i=0;i<8;i++)for(n=0;n<128;n++)OLED_GRAM[n][i]=0X00;  
		OLED_Refresh_Gram();//更新显示
	}
	//画点 
	//x:0~127
	//y:0~63
	//t:1 填充 0,清空				   
	void OLED_DrawPoint(u8 x,u8 y,u8 t)
	{
		u8 pos,bx,temp=0;
		if(x>127||y>63)return;//超出范围了.
		pos=7-y/8;
		bx=y%8;
		temp=1<<(7-bx);
		if(t)OLED_GRAM[x][pos]|=temp;
		else OLED_GRAM[x][pos]&=~temp;	    
	}

	//在指定位置显示一个字符,包括部分字符
	//x:0~127
	//y:0~63
	//mode:0,反白显示;1,正常显示				 
	//size:选择字体 16/12 
	void OLED_ShowChar(u8 x,u8 y,u8 chr,u8 size,u8 mode)
	{      			    
		u8 temp,t,t1;
		u8 y0=y;
		chr=chr-' ';//得到偏移后的值				   
			for(t=0;t<size;t++)
			{   
			if(size==12)temp=oled_asc2_1206[chr][t];  //调用1206字体
			else temp=oled_asc2_1608[chr][t];		 //调用1608字体 	                          
					for(t1=0;t1<8;t1++)
			{
				if(temp&0x80)OLED_DrawPoint(x,y,mode);
				else OLED_DrawPoint(x,y,!mode);
				temp<<=1;
				y++;
				if((y-y0)==size)
				{
					y=y0;
					x++;
					break;
				}
			}  	 
			}          
	}
	//m^n函数
	u32 oled_pow(u8 m,u8 n)
	{
		u32 result=1;	 
		while(n--)result*=m;    
		return result;
	}				  
	//显示2个数字
	//x,y :起点坐标	 
	//len :数字的位数
	//size:字体大小
	//mode:模式	0,填充模式;1,叠加模式
	//num:数值(0~4294967295);	 		  
	void OLED_ShowNumber(u8 x,u8 y,u32 num,u8 len,u8 size)
	{         	
		u8 t,temp;
		u8 enshow=0;						   
		for(t=0;t<len;t++)
		{
			temp=(num/oled_pow(10,len-t-1))%10;
			if(enshow==0&&t<(len-1))
			{
				if(temp==0)
				{
					OLED_ShowChar(x+(size/2)*t,y,' ',size,1);
					continue;
				}else enshow=1; 
				 
			}
			OLED_ShowChar(x+(size/2)*t,y,temp+'0',size,1); 
		}
	} 
	//显示字符串
	//x,y:起点坐标  
	//*p:字符串起始地址
	//用16字体
	void OLED_ShowString(u8 x,u8 y,const u8 *p)
	{
		#define MAX_CHAR_POSX 122
		#define MAX_CHAR_POSY 58          
		while(*p!='\0')
		{       
			if(x>MAX_CHAR_POSX){x=0;y+=16;}
			if(y>MAX_CHAR_POSY){y=x=0;OLED_Clear();}
			OLED_ShowChar(x,y,*p,12,1);	 
			x+=8;
			p++;
		}  
	}	   
	//初始化OLED					    
	void OLED_Init(GPIOChannelType channel, u8 portRst,u8 portDc,u8 portScl,u8 portSda)
	{	
		u16 gpioPort = getGPIOPortByNumber(portRst) | getGPIOPortByNumber(portDc) | getGPIOPortByNumber(portScl) | getGPIOPortByNumber(portSda);
		oledRst = portRst;
		oledDc = portDc;
		oledScl = portScl;
		oledSda = portSda;
		
		RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);//使能AFIO时钟
		//推挽输出,2M
		setGPIOConfiguration(channel,gpioPort,GPIO_Mode_Out_PP,GPIO_Speed_2MHz);
		
		PWR_BackupAccessCmd(ENABLE);//允许修改RTC 和后备寄存器
		RCC_LSEConfig(RCC_LSE_OFF);//关闭外部低速外部时钟信号功能 后，PC13 PC14 PC15 才可以当普通IO用。
		BKP_TamperPinCmd(DISABLE);//关闭入侵检测功能，也就是 PC13，也可以当普通IO 使用
		PWR_BackupAccessCmd(DISABLE);//禁止修改后备寄存器

		OLED_RST_Clr();
//		delay_ms(100);
		OLED_RST_Set(); 
							
		OLED_WR_Byte(0xAE,OLED_CMD); //关闭显示
		OLED_WR_Byte(0xD5,OLED_CMD); //设置时钟分频因子,震荡频率
		OLED_WR_Byte(80,  OLED_CMD);   //[3:0],分频因子;[7:4],震荡频率
		OLED_WR_Byte(0xA8,OLED_CMD); //设置驱动路数
		OLED_WR_Byte(0X3F,OLED_CMD); //默认0X3F(1/64) 
		OLED_WR_Byte(0xD3,OLED_CMD); //设置显示偏移
		OLED_WR_Byte(0X00,OLED_CMD); //默认为0

		OLED_WR_Byte(0x40,OLED_CMD); //设置显示开始行 [5:0],行数.
																
		OLED_WR_Byte(0x8D,OLED_CMD); //电荷泵设置
		OLED_WR_Byte(0x14,OLED_CMD); //bit2，开启/关闭
		OLED_WR_Byte(0x20,OLED_CMD); //设置内存地址模式
		OLED_WR_Byte(0x02,OLED_CMD); //[1:0],00，列地址模式;01，行地址模式;10,页地址模式;默认10;
		OLED_WR_Byte(0xA1,OLED_CMD); //段重定义设置,bit0:0,0->0;1,0->127;
		OLED_WR_Byte(0xC0,OLED_CMD); //设置COM扫描方向;bit3:0,普通模式;1,重定义模式 COM[N-1]->COM0;N:驱动路数
		OLED_WR_Byte(0xDA,OLED_CMD); //设置COM硬件引脚配置
		OLED_WR_Byte(0x12,OLED_CMD); //[5:4]配置
			 
		OLED_WR_Byte(0x81,OLED_CMD); //对比度设置
		OLED_WR_Byte(0xEF,OLED_CMD); //1~255;默认0X7F (亮度设置,越大越亮)
		OLED_WR_Byte(0xD9,OLED_CMD); //设置预充电周期
		OLED_WR_Byte(0xf1,OLED_CMD); //[3:0],PHASE 1;[7:4],PHASE 2;
		OLED_WR_Byte(0xDB,OLED_CMD); //设置VCOMH 电压倍率
		OLED_WR_Byte(0x30,OLED_CMD); //[6:4] 000,0.65*vcc;001,0.77*vcc;011,0.83*vcc;

		OLED_WR_Byte(0xA4,OLED_CMD); //全局显示开启;bit0:1,开启;0,关闭;(白屏/黑屏)
		OLED_WR_Byte(0xA6,OLED_CMD); //设置显示方式;bit0:1,反相显示;0,正常显示	    						   
		OLED_WR_Byte(0xAF,OLED_CMD); //开启显示	 
		OLED_Clear();
	}  

	//测试用例
	void Test_OLED()
	{
		OLED_Init(ChannelC,15,0,13,14);
		OLED_ShowString(00,20,"LEFT");
		OLED_ShowNumber(75,20,123456,6,12);
		OLED_Refresh_Gram();
	}

#endif
//-----------------------end of OLED------------------------------------------------------

//-----------------------Hall------------------------------------------------------
#ifdef COMPONENTS_HALL
	
	#define ENCODER_TIM_PERIOD 0xFFFF	
	#define MAX_NUMBER_COUNT 31
	
	int _TIM4_BaseCounter = 0;
	int _TIM2_BaseCounter = 0;
	int hallSpeedArray[2];
	int hallValueArray[2][MAX_NUMBER_COUNT];
	u8 checkTimeLength=0, speedJumpCount = 0;	

	void HallEncoderInit(GPIOConfigStruct* channelInfo, u8 channelCount, HallEncoderIndex encoderIdx)
	{
		u32 rccChannel = RCC_APB1Periph_TIM2;
		u8 IRQChannel = TIM2_IRQn;
		TIM_TypeDef * pTimeType = TIM2;
		if(encoderIdx != First && encoderIdx != Second)
		{
			return;
		}
		else if(encoderIdx == Second)
		{
			rccChannel = RCC_APB1Periph_TIM4;	
			IRQChannel=TIM4_IRQn;
			pTimeType = TIM4;
		}	
		RCC_APB1PeriphClockCmd(rccChannel, ENABLE);
		setGPIOConfiguration2(channelInfo,channelCount,GPIO_Mode_IN_FLOATING,GPIO_Speed_50MHz);	
		
		TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;  
		TIM_ICInitTypeDef TIM_ICInitStructure;
		NVIC_InitTypeDef  NVIC_InitStructure;
		
		NVIC_InitStructure.NVIC_IRQChannel = IRQChannel;
		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
		NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
		NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
		NVIC_Init(&NVIC_InitStructure);

		TIM_TimeBaseStructInit(&TIM_TimeBaseStructure);
		TIM_TimeBaseStructure.TIM_Prescaler = 0x00; // 预分频器 
		TIM_TimeBaseStructure.TIM_Period = ENCODER_TIM_PERIOD; //设置编码器中断溢出阈值
		TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;//选择时钟分频：不分频
		TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;////TIM向上计数  
		TIM_TimeBaseInit(pTimeType, &TIM_TimeBaseStructure);
		TIM_EncoderInterfaceConfig(pTimeType, TIM_EncoderMode_TI12, TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);//使用编码器模式3
		TIM_ICStructInit(&TIM_ICInitStructure);
		TIM_ICInitStructure.TIM_ICFilter = 10;
		TIM_ICInit(pTimeType, &TIM_ICInitStructure);
		TIM_ClearFlag(pTimeType, TIM_FLAG_Update);//清除TIM的更新标志位
		TIM_ITConfig(pTimeType, TIM_IT_Update, ENABLE);
		TIM_SetCounter(pTimeType,0);//清零计数器初始值
		TIM_Cmd(pTimeType, ENABLE); 
	}
	
	/**************************************************************************
	函数功能：TIM4中断服务函数
	入口参数：无
	返回  值：无
	**************************************************************************/
	void TIM4_IRQHandler(void)
	{ 		    		  			    
		/*if(TIM4->SR&0X0001)//溢出中断
		{    				   				     	    	
		}				   
		TIM4->SR&=~(1<<0);//清除中断标志位 	
		TIM4 -> CNT=0;*/
		if(TIM_GetITStatus(TIM4, TIM_IT_Update) != RESET)
		{
			if(TIM4->CNT <= 0x00FF) _TIM4_BaseCounter += ENCODER_TIM_PERIOD;
			else if(TIM4->CNT >= 0xFF00) _TIM4_BaseCounter -= ENCODER_TIM_PERIOD;
			TIM_ClearITPendingBit(TIM4, TIM_IT_Update); 
		}	
	}
	/**************************************************************************
	函数功能：TIM2中断服务函数
	入口参数：无
	返回  值：无
	**************************************************************************/
	void TIM2_IRQHandler(void)
	{ 		    		  			    
		/*if(TIM2->SR&0X0001)//溢出中断
		{    				   				     	    	
		}				   
		TIM2->SR&=~(1<<0);//清除中断标志位 	 
		TIM2 -> CNT=0;	*/
		if(TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)
		{
			if(TIM2->CNT <= 0x00FF) _TIM2_BaseCounter += ENCODER_TIM_PERIOD;
			else if(TIM2->CNT >= 0xFF00) _TIM2_BaseCounter -= ENCODER_TIM_PERIOD;
			TIM_ClearITPendingBit(TIM2, TIM_IT_Update); 
		}	
	}

	int Read_ABS_Value(HallEncoderIndex encoderIdx)
	{
		int tempResult = 0;
		if(encoderIdx == First)
		{
			tempResult = _TIM2_BaseCounter + (int)(TIM2->CNT);
		}
		else if(encoderIdx == Second)
		{
			tempResult = _TIM4_BaseCounter + (int)(TIM4->CNT);
		}
		return tempResult;
	}	
	
	void calcHallMoveSpeed(void)
	{
		if(speedJumpCount < checkTimeLength)
		{
			speedJumpCount ++;
			return;
		}
		speedJumpCount = 0;
		HallEncoderIndex encoderIdx;
		for(int i=0;i<2;i++)
		{
			encoderIdx = (i==0?First:Second);
			moveArrayForward(MAX_NUMBER_COUNT,hallValueArray[i]);
			hallValueArray[i][MAX_NUMBER_COUNT-1] = Read_ABS_Value(encoderIdx);
			hallSpeedArray[i] = (hallValueArray[i][MAX_NUMBER_COUNT-1] - hallValueArray[i][MAX_NUMBER_COUNT-2]) * (1000 / 5 / checkTimeLength);
		}
	}
	
	void HallSpeedInitial(u8 timesFor5ms)
	{
		if(timesFor5ms <= 0) return;
		
		checkTimeLength = timesFor5ms;
		
		Config_TIMER(TIMER_3,1,200);//每秒200次中断（5ms一次）
		Timer_Register(TIMER_3,calcHallMoveSpeed);
	}	
	
	int getHallChangeSpeed(HallEncoderIndex encoderIdx)
	{
		int tempSpeed = hallSpeedArray[0];
		
		if(encoderIdx == Second)
		{
			tempSpeed = hallSpeedArray[1];
		}
		
		return tempSpeed;
	}
	
	//测试用例
	void TEST_HallEncoder(void)
	{
		//获取霍尔传感器的数值
		GPIOConfigStruct hallEncoderConfig[2]=
		{
			{ChannelA,{0,1},2},
			{ChannelB,{6,7},2}
		};
		HallEncoderInit(hallEncoderConfig,1,First);
		int encoderLeft = Read_ABS_Value(First);		
		HallEncoderInit(&hallEncoderConfig[1],1,Second);	
		int encoderRight = Read_ABS_Value(Second);
		
		
		//获取霍尔传感器的变化速度
		HallSpeedInitial(20);
		int speedLeft = getHallChangeSpeed(First);
		int speedRight = getHallChangeSpeed(Second);
		
		int clearWarnning = encoderLeft + encoderRight + speedLeft + speedRight;
		clearWarnning = clearWarnning + 1;
	}
#endif
//-----------------------end of Hall------------------------------------------------------

//----------------------- 电机 ------------------------------------------------------
#ifdef COMPONENTS_MOTOR

	#define IO_ADDRES_CONFIGURATION	
	#include "Tools.h"
	
	u32 leftWheelForward, leftWheelBackward, rightWheelForward, rightWheelBackward;
	u8 leftWheelFPin,leftWheelBPin,rightWheelFPin,rightWheelBPin;
	
	u32 getGPIOODRAddr(GPIOChannelType channelType)
	{
		u32 tempAddr= GPIOA_ODR_Addr;
		switch(channelType)
		{
			case ChannelB:tempAddr= GPIOB_ODR_Addr;break;
			case ChannelC:tempAddr= GPIOC_ODR_Addr;break;
			case ChannelD:tempAddr= GPIOD_ODR_Addr;break;
			case ChannelE:tempAddr= GPIOE_ODR_Addr;break;
			case ChannelF:tempAddr= GPIOF_ODR_Addr;break;
			case ChannelG:tempAddr= GPIOG_ODR_Addr;break;
			default:break;
		}
		return tempAddr;
	}
	
	void explainInitialParams(WheelGPIOInfo wheelConfig[])
	{
		leftWheelForward = getGPIOODRAddr(wheelConfig[0].forwardType);
		leftWheelFPin = wheelConfig[0].forwardGPIOPin;
		leftWheelBackward = getGPIOODRAddr(wheelConfig[0].backwardType);
		leftWheelBPin = wheelConfig[0].backwardGPIOPin;		
		
		rightWheelForward = getGPIOODRAddr(wheelConfig[1].forwardType);
		rightWheelFPin = wheelConfig[1].forwardGPIOPin;
		rightWheelBackward = getGPIOODRAddr(wheelConfig[1].backwardType);
		rightWheelBPin = wheelConfig[1].backwardGPIOPin;
	}
	
	void PWMBalanceCarInitial(GPIOConfigStruct channelsMotor[],u8 channelMotorCount,WheelGPIOInfo wheelConfig[], GPIOConfigStruct channelsPwm[],u8 channelPwmCount,u16 period,u16 prescaler)
	{		
		explainInitialParams(wheelConfig);
		setGPIOConfiguration2(channelsMotor,channelMotorCount,GPIO_Mode_Out_PP, GPIO_Speed_50MHz);
		setGPIOConfiguration2(channelsPwm,channelPwmCount,GPIO_Mode_AF_PP, GPIO_Speed_50MHz);
				
		TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
		TIM_OCInitTypeDef  TIM_OCInitStructure;
		RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);// 

		TIM_TimeBaseStructure.TIM_Period = period; //设置在下一个更新事件装入活动的自动重装载寄存器周期的值	 
		TIM_TimeBaseStructure.TIM_Prescaler =prescaler; //设置用来作为TIMx时钟频率除数的预分频值  不分频
		TIM_TimeBaseStructure.TIM_ClockDivision = 0; //设置时钟分割:TDTS = Tck_tim
		TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式
		TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure); //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位


		TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; //选择定时器模式:TIM脉冲宽度调制模式1
		TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; //比较输出使能
		TIM_OCInitStructure.TIM_Pulse = 0;                            //设置待装入捕获比较寄存器的脉冲值
		TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;     //输出极性:TIM输出比较极性高
		TIM_OC1Init(TIM1, &TIM_OCInitStructure);  //根据TIM_OCInitStruct中指定的参数初始化外设TIMx
		TIM_OC4Init(TIM1, &TIM_OCInitStructure);  //根据TIM_OCInitStruct中指定的参数初始化外设TIMx

		TIM_CtrlPWMOutputs(TIM1,ENABLE);	//MOE 主输出使能	

		TIM_OC1PreloadConfig(TIM1, TIM_OCPreload_Enable);  //CH1预装载使能	 
		TIM_OC4PreloadConfig(TIM1, TIM_OCPreload_Enable);  //CH4预装载使能	 

		TIM_ARRPreloadConfig(TIM1, ENABLE); //使能TIMx在ARR上的预装载寄存器

		TIM_Cmd(TIM1, ENABLE);  //使能TIM1
	}
	
	void SetPwmValue(int leftPwm,int rightPwm)
	{
		u8 forward = 1, backward = 0;
		if(leftPwm < 0)
		{
			forward = 0;
			backward = 1;
			leftPwm *= -1;
		}
		BIT_ADDR(leftWheelForward,leftWheelFPin)=forward;
		BIT_ADDR(leftWheelBackward,leftWheelBPin)=backward;		
		TIM1->CCR1 = leftPwm;
		
		forward = 1;
		backward = 0;	
		if(rightPwm < 0)
		{
			forward = 0;
			backward = 1;
			rightPwm *= -1;
		}		
		BIT_ADDR(rightWheelForward,rightWheelFPin)=forward;
		BIT_ADDR(rightWheelBackward,rightWheelBPin)=backward;
		TIM1->CCR4 = rightPwm;
	}
	
	//测试用例
	void TEST_PwmMotor(void)
	{
		GPIOConfigStruct motorGPIOConfig[2] = {
			{ChannelC,{8,9,12},3},
			{ChannelA,{15},1},
		};
		WheelGPIOInfo wheelGPIOConfig[2] = {
			{ChannelC,9,ChannelC,8},
			{ChannelA,15,ChannelC,12}
		};
		GPIOConfigStruct pwmGPIOConfig[1] = {
			{ChannelA,{8,11},2},
		};
		PWMBalanceCarInitial(motorGPIOConfig,2,wheelGPIOConfig,pwmGPIOConfig,1,7199,0);
		while(1)
		{
			//控制小车轮子转动
			SetPwmValue(1000,3000);
		}
	}
#endif
	
//-----------------------end of 电机 ------------------------------------------------------

//----------------------- 设备安全检查 ------------------------------------------------------
#ifdef DEVICE_SAFETY_CHECK
	
	#define USE_FILTER
	#define DATA_ARRAY_HANDLE
	#define USE_ADC
	#include "Tools.h"
	#include "Device.h"
	
	#define 	CHECK_COUNT 									2
	#define 	ADC_WEIGHT_FILTER_WINDOW_SIZE	16
	//所有ADC值默认的参考电压为3.3v
	#define		ADC_RESOLUTION_10		1024		//10位AD的分辨率
	#define  	ADC_RESOLUTION_12		4096		//12位AD的分辨率
	
	StructAdcInfo adcInfoArray[CHECK_COUNT];
	StructCheckOverload g_check_info[CHECK_COUNT];
	StructAdcDelayInfo adcDelayInfo[CHECK_COUNT];
	u8 adcValueChannelIdx[ADC_VALUE_COUNT];
	
	void FilterADCValue(void)
	{
		StructAdcInfo *tempAdcInfo = &adcInfoArray[HardWare_ADC1];
		for(int i=0;i<ADC_VALUE_COUNT;i++)
		{
			(*tempAdcInfo).adcSourceValuesArray[i] = Get_ADC_Value(i);
			(*tempAdcInfo).adcWeightFilterValuesArray[i] = weightFilter((*tempAdcInfo).weightFilterIdxArray[i],(*tempAdcInfo).adcSourceValuesArray[i]);
			(*tempAdcInfo).adcFilterResultValuesArray[i] = averageFilter((*tempAdcInfo).averageFilterIdxArray[i],(*tempAdcInfo).adcWeightFilterValuesArray[i]);
		}
	}
	
	void AdcDelayTimerCheck(void)
	{
		for(u8 i = 0; i < CHECK_COUNT; i ++)
		{
			if(!adcDelayInfo[i].StartFlag) continue;
			
			adcDelayInfo[i].TimeCount ++;
			if(adcDelayInfo[i].TimeCount >= adcDelayInfo[i].Time)
			{
				adcDelayInfo[i].TimeCount = 0;
				adcDelayInfo[i].Success = 1;
				adcDelayInfo[i].StartFlag = 0;
			}
		}
	}
	
	void AdcErrorTimerCheck(void)
	{
		for(u8 i = 0; i < CHECK_COUNT; i ++)
		{	//过载计时
			if(g_check_info[i].overload_time_flag)
			{
				g_check_info[i].load_error_time ++;
				if(g_check_info[i].load_error_time >= g_check_info[i].stall_time)
				{
					g_check_info[i].load_error_time = 0;
					g_check_info[i].overload_flag = 1;		//过载标志
				}
			}
			else
			{
				g_check_info[i].load_error_time = 0;
			}
			//当检测到过流后，或者过载后，电机处于保护阶段，当过一段时间后，电机就恢复
			if(g_check_info[i].overload_flag)
			{
				g_check_info[i].free_load_error_time ++;
				if(g_check_info[i].free_load_error_time >= g_check_info[i].free_time)
				{
					g_check_info[i].free_load_error_time = 0;
					g_check_info[i].overload_flag = 0;
				}
			}
			//-------------------------------------------------//
			if(g_check_info[i].overcurrent_time_flag)
			{
				g_check_info[i].current_error_time ++;
				if(g_check_info[i].current_error_time >= g_check_info[i].stall_time)
				{
					g_check_info[i].current_error_time = 0;
					g_check_info[i].overcurrent_flag = 1;
				}
			}
			else
			{
				g_check_info[i].current_error_time = 0;
			}
			//当检测到过流后，或者过载后，电机处于保护阶段，当过一段时间后，电机就恢复
			if(g_check_info[i].overcurrent_flag)
			{
				g_check_info[i].free_cur_error_time ++;
				if(g_check_info[i].free_cur_error_time >= g_check_info[i].free_time)
				{
					g_check_info[i].free_cur_error_time = 0;
					g_check_info[i].overcurrent_flag = 0;
				}
			}
			//过压标志
			if(g_check_info[i].overvoltage_time_flag)
			{
				g_check_info[i].overvoltage_error_time ++;
				if(g_check_info[i].overvoltage_error_time >= g_check_info[i].stall_time)
				{
					g_check_info[i].overvoltage_error_time = 0;
					g_check_info[i].overvoltage_flag = 1;
				}
			}
			else
			{
				g_check_info[i].overvoltage_error_time = 0;
				g_check_info[i].overvoltage_flag = 0;
			}
			//欠压标志
			if(g_check_info[i].undervoltage_time_flag)
			{
				g_check_info[i].undervoltage_error_time ++;
				if(g_check_info[i].undervoltage_error_time >= g_check_info[i].stall_time)
				{
					g_check_info[i].undervoltage_error_time = 0;
					g_check_info[i].undervoltage_flag = 1;
				}
			}
			else
			{
				g_check_info[i].undervoltage_error_time = 0;
				g_check_info[i].undervoltage_flag = 0;
			}	
		}
	}
	
	void ReadOffsetCurrentValue(u8 chkIdx,u8 adcInfoIdx)
	{
		u8 adcDelayIdx = g_check_info[chkIdx].offset_delay_id;
		adcDelayInfo[adcDelayIdx].Time = 200;
		adcDelayInfo[adcDelayIdx].StartFlag = 1;
		while(!adcDelayInfo[adcDelayIdx].Success)
		{
			FilterADCValue();
			
			u16 tempAdcValue = adcInfoArray[HardWare_ADC1].adcFilterResultValuesArray[adcInfoIdx];
			g_check_info[chkIdx].cur_offset_dc = weightFilter(g_check_info[chkIdx].weightFilterIdx,tempAdcValue);
		}
		g_check_info[chkIdx].stall_sum = g_check_info[chkIdx].cur_offset_dc + g_check_info[chkIdx].stall_cmp;
		g_check_info[chkIdx].cur_last_value = g_check_info[chkIdx].cur_offset_dc;
		
	}
	
	void UpdateVolCurValue(u8 chkIdx, u8 voltIdx, u8 curIdx)
	{
		g_check_info[chkIdx].current_adc = adcInfoArray[HardWare_ADC1].adcFilterResultValuesArray[curIdx];
		g_check_info[chkIdx].voltage_adc = adcInfoArray[HardWare_ADC1].adcFilterResultValuesArray[voltIdx];
	}
	
	void GetVolCurValue(u8 chkIdx, u8 * voltage, u8 * current)
	{
		* voltage = g_check_info[chkIdx].voltage_adc;
		* current = g_check_info[chkIdx].current_adc;
	}
	
	void motorSafetyCheckInitital(StructMotorSafeInfo initialInfo[],u8 infoCount)
	{
		if(infoCount > CHECK_COUNT) return;
		u16 adcResolution = ADC_RESOLUTION_10;
		#ifdef	ADC_12_BIT
		adcResolution = ADC_RESOLUTION_12;
		#endif
		u8 i;
		for(i = 0; i < infoCount; i ++)
		{
			g_check_info[i].stall_time = initialInfo[i].stallTime;			//time is 500ms.
			g_check_info[i].stall_current = initialInfo[i].stallCurrent;		//current is 4000ma.
			g_check_info[i].free_time = initialInfo[i].freeTime;			//等待3S后，电机会恢复
			g_check_info[i].max_voltage = initialInfo[i].maxWorkVoltage * initialInfo[i].voltageRatio * adcResolution / 3.3;
			g_check_info[i].min_voltage = initialInfo[i].minWorkVoltage * initialInfo[i].voltageRatio * adcResolution / 3.3;
			g_check_info[i].current_adc = 0;
			g_check_info[i].current_error_time = 0;
			g_check_info[i].stall_cmp = g_check_info[i].stall_current * 0.373; //默认0.744
	//		GetDelayIdFunction(1, &g_check_info[i].offset_delay_id);
		}
		//初始化滤波器
		for(i=0;i<ADC_VALUE_COUNT;i++)
		{
			adcInfoArray[HardWare_ADC1].weightFilterIdxArray[i] = weightFilterInitial(16);
			adcInfoArray[HardWare_ADC1].averageFilterIdxArray[i] = averageFilterInitial(32);
		}
		for(i=0;i<CHECK_COUNT;i++)
		{
			g_check_info[i].weightFilterIdx = weightFilterInitial(ADC_BUF_SIZE);
		}
		//5ms为单位
		Timer_Register(TIMER_3,AdcDelayTimerCheck);
		Timer_Register(TIMER_3,AdcErrorTimerCheck);
	}
	
	void GeneralSafetyCheck(void)
	{
		for(u8 i = 0; i < CHECK_COUNT; i ++)
		{
			g_check_info[i].cur_offset = g_check_info[i].current_adc - g_check_info[i].cur_last_value;
			g_check_info[i].cur_offset_sum += g_check_info[i].cur_offset;	
			g_check_info[i].cur_last_value = g_check_info[i].current_adc;
			//过载检测
			if((g_check_info[i].cur_offset_sum > 0) && (g_check_info[i].cur_offset_sum >= g_check_info[i].stall_cmp))
				g_check_info[i].overload_time_flag = 1;		
			else
				g_check_info[i].overload_time_flag = 0;
			//过流检测
			if(g_check_info[i].current_adc >= g_check_info[i].stall_sum) 
				g_check_info[i].overcurrent_time_flag = 1;
			else
				g_check_info[i].overcurrent_time_flag = 0;
			//过压和欠压检测
			if(g_check_info[i].max_voltage > 0 && g_check_info[i].min_voltage > 0)
			{				
				if(g_check_info[i].voltage_adc >= g_check_info[i].max_voltage)
					g_check_info[i].overvoltage_time_flag = 1;
				else
					g_check_info[i].overvoltage_time_flag = 0;
				
				if(g_check_info[i].voltage_adc <= g_check_info[i].min_voltage)
					g_check_info[i].undervoltage_time_flag = 1;
				else
					g_check_info[i].undervoltage_time_flag = 0;
			}
		}
	}
	
	
	void TEST_SafetyCheck(void)
	{
		//AD转换模块初始化
		StructAdcChannelInfo adcChannelInfo[6] = {
			{GPIO_Pin_3,ADC_Channel_3,GPIOA},
			{GPIO_Pin_4,ADC_Channel_4,GPIOA},
			{GPIO_Pin_5,ADC_Channel_5,GPIOA},
			{GPIO_Pin_6,ADC_Channel_6,GPIOA},
			{GPIO_Pin_7,ADC_Channel_7,GPIOA},
			{GPIO_Pin_4,ADC_Channel_14,GPIOC}
		};
		DeviceADCInitial(adcChannelInfo,6);
		//电机安全检测初始化
		StructMotorSafeInfo motorSafeInfo[2] = {
			{2500,500,1400,0.001, 14, 9},
			{2500,500,1400,0.001, 14, 9}
		};
		motorSafetyCheckInitital(motorSafeInfo,2);
		//采集通道数据
		ReadOffsetCurrentValue(0, 2);
		ReadOffsetCurrentValue(1, 3);
		u8 leftVol, leftCur, rightVol, rightCur;
		while(1)
		{		
			//电机安全检测
			FilterADCValue();
			UpdateVolCurValue(0,1,2);
			UpdateVolCurValue(1,1,3);
			GeneralSafetyCheck();
			//显示电流电压值
			GetVolCurValue(0, &leftVol,&leftCur);
			GetVolCurValue(1, &rightVol,&rightCur);
		}		
	}
	
#endif
//-----------------------end of 设备安全检查 ------------------------------------------------------

